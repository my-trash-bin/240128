enum UserRole {
  NONE
  SELLER
  SUPER_SELLER
  ADMIN
}

model User {
  id        Int      @id @default(autoincrement())
  role      UserRole
  createdAt DateTime @default(now())

  // Separating User and UserProfile/UserAuthentication/... models to maintain a manageable size for the User model
  profileId        Int @unique
  authenticationId Int @unique

  // relationships
  relationsSmaller          UserRelation[]              @relation("UserRelation_smaller")
  relationsBigger           UserRelation[]              @relation("UserRelation_bigger")
  relationCacheFrom         UserRelationCacheByUser[]   @relation("UserRelationCacheByUser_from")
  relationCacheTo           UserRelationCacheByUser[]   @relation("UserRelationCacheByUser_to")
  relationFriendRequestFrom UserRelationFriendRequest[] @relation("UserRelationFriendRequest_from")
  relationFriendRequestTo   UserRelationFriendRequest[] @relation("UserRelationFriendRequest_to")
  following                 UserFollow[]                @relation("UserFollow_from")
  followed                  UserFollow[]                @relation("UserFollow_to")

  // other 1:n
  passwordHistory          UserPasswordHistory[]
  email                    UserEmail[]
  actor                    Actor?
  ownedGroups              Group[]
  groups                   GroupMember[]
  articleEditHistory       ArticleEditHistory[]
  userPasswordResetRequest UserPasswordResetRequest[]
  transactions             Transaction[]
  inquiries                Inquiry[]

  // 1:1
  profile        UserProfile        @relation(fields: [profileId], references: [id])
  authentication UserAuthentication @relation(fields: [authenticationId], references: [id])
}

model UserRelation {
  userIdSmaller Int
  userIdBigger  Int
  createdAt     DateTime @default(now())

  smaller User                      @relation("UserRelation_smaller", fields: [userIdSmaller], references: [id])
  bigger  User                      @relation("UserRelation_bigger", fields: [userIdBigger], references: [id])
  byUser  UserRelationCacheByUser[]

  @@id([userIdSmaller, userIdBigger])
}

model UserRelationCacheByUser {
  // 2 rows for each UserRelation row
  fromId Int
  toId   Int

  keySmaller Int
  keyBigger  Int

  isFriend       Boolean  @default(true)
  createdAtCache DateTime // from UserRelation::createdAt

  from     User         @relation("UserRelationCacheByUser_from", fields: [fromId], references: [id])
  to       User         @relation("UserRelationCacheByUser_to", fields: [toId], references: [id])
  relation UserRelation @relation(fields: [keySmaller, keyBigger], references: [userIdSmaller, userIdBigger])

  @@id([fromId, toId])
  @@index([fromId, isFriend, createdAtCache])
}

model UserRelationFriendRequest {
  fromId           Int
  toId             Int
  articleId        Int      @unique
  createdAt        DateTime @default(now())
  isCancelled      Boolean
  isRejected       Boolean
  isAvailableCache Boolean // !isCancelled && !isRejected

  from    User    @relation("UserRelationFriendRequest_from", fields: [fromId], references: [id])
  to      User    @relation("UserRelationFriendRequest_to", fields: [toId], references: [id])
  article Article @relation(fields: [articleId], references: [id])

  @@id([fromId, toId])
  @@index([fromId, createdAt])
  @@index([toId, createdAt])
  @@index([fromId, isAvailableCache, createdAt])
  @@index([toId, isAvailableCache, createdAt])
}

model UserFollow {
  fromId    Int
  toId      Int
  createdAt DateTime @default(now())

  from User @relation("UserFollow_from", fields: [fromId], references: [id])
  to   User @relation("UserFollow_to", fields: [toId], references: [id])

  @@id([fromId, toId])
  @@index([fromId, createdAt])
  @@index([toId, createdAt])
}

model UserAuthentication {
  id           Int    @id @default(autoincrement())
  passwordHash String // hash(userId, password)

  user         User?
  oauth        OAuth[]
  loginHistory UserLoginHistory[]
}

enum OAuthProvider {
  NAVER
  KAKAO
}

model OAuth {
  id       Int           @id @default(autoincrement())
  provider OAuthProvider
  oauthId  String
  userId   Int?

  user         UserAuthentication? @relation(fields: [userId], references: [id])
  loginHistory UserLoginHistory[]

  @@unique([provider, oauthId])
}

model UserPasswordResetRequest {
  userId       Int
  email        String
  createdAt    DateTime
  expiresAt    DateTime
  passwordHash String
  resetAt      DateTime?
  cancelledAt  DateTime?
  isValidCache Boolean // resetAt === null && cancelledAt === null

  user User @relation(fields: [userId], references: [id])

  @@id([userId, createdAt])
  @@index([userId, isValidCache, createdAt])
}

model UserLoginHistory {
  userAuthenticationId Int
  createdAt            DateTime @default(now())
  ipAddress            String
  oauthId              Int?

  userAuthentication UserAuthentication @relation(fields: [userAuthenticationId], references: [id])
  oauth              OAuth?             @relation(fields: [oauthId], references: [id])

  @@id([userAuthenticationId, createdAt])
}

model UserProfile {
  id             Int    @id @default(autoincrement())
  nickname       String @unique
  introductionId Int?   @unique
  profileImageId Int?

  User         User?
  introduction Article?    @relation(fields: [introductionId], references: [id])
  profileImage PublicFile? @relation(fields: [profileImageId], references: [id])
}

model UserPasswordHistory {
  // To prevent user set password previously used
  userId       Int
  passwordHash String // hash(userId, password)

  user User @relation(fields: [userId], references: [id])

  @@id([userId, passwordHash])
}

model UserEmail {
  email        String   @id
  userId       Int?
  blockedCache Boolean // true if userId is null
  createdAt    DateTime @default(now())

  user User? @relation(fields: [userId], references: [id])

  @@index([blockedCache, email])
}

model Group {
  id             Int    @id @default(autoincrement())
  name           String @unique
  introductionId Int?   @unique
  profileImageId Int?

  ownerId Int

  owner        User            @relation(fields: [ownerId], references: [id])
  members      GroupMember[]
  actor        Actor?
  auditLog     GroupAuditLog[]
  introduction Article?        @relation(fields: [introductionId], references: [id])
  profileImage PublicFile?     @relation(fields: [profileImageId], references: [id])
}

model GroupMember {
  groupId Int
  userId  Int

  group Group @relation(fields: [groupId], references: [id])
  user  User  @relation(fields: [userId], references: [id])

  @@id([groupId, userId])
}

model GroupAuditLog {
  id        Int      @id @default(autoincrement())
  groupId   Int
  createdAt DateTime @default(now())
  logType   Int
  logJson   String

  group Group @relation(fields: [groupId], references: [id])

  @@index([groupId, createdAt])
  @@index([groupId, logType, createdAt])
}

enum ActorType {
  USER
  GROUP
}

model Actor {
  id   Int       @id @default(autoincrement())
  type ActorType

  userId  Int? @unique
  groupId Int? @unique

  user  User?  @relation(fields: [userId], references: [id])
  group Group? @relation(fields: [groupId], references: [id])

  ownedFile                 PublicFile[]
  ownedArticles             Article[]
  editedArticles            ArticleEditHistory[]
  ownedProduct              Product[]
  ownedDigitalProductSeries DigitalProductSeries[]
}

model PublicFile {
  // When upload:
  // 1. create File with referenceCount = 0
  // 2. upload to its ObjectStorage
  // 3. reference File and increase referenceCount at once
  // When collect garbage: delete rows with zero-referenceCount and old enough
  id             Int      @id @default(autoincrement())
  name           String
  providerAndId  String
  referenceCount Int
  ownerId        Int
  markAsDeleted  Boolean
  createdAt      DateTime @default(now())

  owner Actor @relation(fields: [ownerId], references: [id])

  userProfiles  UserProfile[]
  groupProfiles Group[]
  articles      ArticleEditHistoryFile[]

  @@index([referenceCount, createdAt])
}

model PrivateFile {
  // Similar to PublicFile, but for digital product content only.
  id            Int      @id @default(autoincrement())
  name          String
  providerAndId String
  markAsDeleted Boolean
  createdAt     DateTime @default(now())
  productId     Int

  product DigitalProduct @relation(fields: [productId], references: [id])
}

model Article {
  id            Int      @id @default(autoincrement())
  ownerId       Int?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  lastTimeCache DateTime @unique // SELECT MAX(createdAt) FROM ArticleEditHistory WHERE articleId = ${id}

  owner       Actor?             @relation(fields: [ownerId], references: [id])
  lastVersion ArticleEditHistory @relation(fields: [id, createdAt], references: [articleId, createdAt])

  userProfileIntroduction          UserProfile?
  userRelationFriendRequest        UserRelationFriendRequest?
  groupIntroduction                Group?
  review                           Review?
  physicalProductDescription       PhysicalProduct?
  physicalProductAddonDetails      PhysicalProductAddon?
  physicalProductSelectDetails     PhysicalProductSelect?
  physicalProductSelectItemDetails PhysicalProductSelectItem?
  physicalProductOptionDetails     PhysicalProductOption?
  digitalProductDescription        DigitalProduct?
  inquiryQuestion                  Inquiry?                   @relation("Inquiry_question")
  inquiryAnswer                    Inquiry?                   @relation("Inquiry_answer")

  @@unique([id, createdAt])
}

model ArticleEditHistory {
  articleId     Int
  createdAt     DateTime @default(now())
  title         String?
  messageBbcode String
  actorId       Int
  userId        Int

  files   ArticleEditHistoryFile[]
  actor   Actor                    @relation(fields: [actorId], references: [id])
  user    User                     @relation(fields: [userId], references: [id])
  Article Article?

  @@id([articleId, createdAt])
}

model ArticleEditHistoryFile {
  articleEditHistoryId Int
  fileId               Int
  createdAt            DateTime @default(now())

  article ArticleEditHistory @relation(fields: [articleEditHistoryId, createdAt], references: [articleId, createdAt])
  file    PublicFile         @relation(fields: [fileId], references: [id])

  @@id([articleEditHistoryId, fileId])
}

enum ProductType {
  PYHSICAL
  DIGITAL
}

model Product {
  id                Int         @id @default(autoincrement())
  name              String
  description       String
  type              ProductType
  ownerId           Int
  visibilityByOwner Boolean
  visibilityByAdmin Boolean
  visibilityCache   Boolean // visibilityByOwner && visibilityByAdmin

  physicalProductId Int? @unique
  digitalProductId  Int? @unique

  owner Actor @relation(fields: [ownerId], references: [id])

  physicalProduct PhysicalProduct?
  digitalProduct  DigitalProduct?

  reviews   Review[]
  inquiries Inquiry[]
}

model Review {
  id             Int @id @default(autoincrement())
  articleId      Int @unique
  productIdCache Int

  transaction TransactionBuyItem?
  product     Product             @relation(fields: [productIdCache], references: [id])
  article     Article             @relation(fields: [articleId], references: [id])
}

model Inquiry {
  id         Int      @id @default(autoincrement())
  userId     Int
  productId  Int?
  questionId Int      @unique
  answeredAt DateTime
  answerId   Int?     @unique

  user     User     @relation(fields: [userId], references: [id])
  product  Product? @relation(fields: [productId], references: [id])
  question Article  @relation("Inquiry_question", fields: [questionId], references: [id])
  answer   Article? @relation("Inquiry_answer", fields: [answerId], references: [id])

  @@index([userId, productId])
  @@index([productId, userId])
}

model PhysicalProduct {
  // user can buy same physical product multiple times
  id            Int  @id @default(autoincrement())
  productId     Int  @unique
  descriptionId Int  @unique
  price         Int
  stockQuantity Int?

  product Product @relation(fields: [productId], references: [id])

  description  Article                          @relation(fields: [descriptionId], references: [id])
  addons       PhysicalProductAddon[]
  selects      PhysicalProductSelect[]
  options      PhysicalProductOption[]
  transactions TransactionBuyItemPhysicalItem[]
}

model PhysicalProductAddon {
  id                  Int    @id @default(autoincrement())
  productId           Int
  price               Int
  stockQuantity       Int?
  allowedCountPerItem Int
  name                String
  detailsId           Int?   @unique

  product      PhysicalProduct                  @relation(fields: [productId], references: [id])
  details      Article?                         @relation(fields: [detailsId], references: [id])
  transactions TransactionBuyItemPhysicalItem[]
}

model PhysicalProductSelect {
  id            Int    @id @default(autoincrement())
  productId     Int
  name          String
  detailsId     Int?   @unique
  defaultItemId Int?   @unique

  product     PhysicalProduct             @relation(fields: [productId], references: [id])
  details     Article?                    @relation(fields: [detailsId], references: [id])
  defaultItem PhysicalProductSelectItem?  @relation("PhysicalProductSelect_defaultItem", fields: [defaultItemId], references: [id])
  items       PhysicalProductSelectItem[] @relation("PhysicalProductSelectItem_parent")
}

model PhysicalProductSelectItem {
  id              Int    @id @default(autoincrement())
  selectId        Int
  additionalPrice Int
  name            String
  detailsId       Int?   @unique

  parent       PhysicalProductSelect            @relation("PhysicalProductSelectItem_parent", fields: [selectId], references: [id])
  default      PhysicalProductSelect?           @relation("PhysicalProductSelect_defaultItem")
  details      Article?                         @relation(fields: [detailsId], references: [id])
  transactions TransactionBuyItemPhysicalItem[]
}

model PhysicalProductOption {
  id              Int    @id @default(autoincrement())
  productId       Int
  additionalPrice Int
  name            String
  detailsId       Int?   @unique
  valueTypeJson   String

  product PhysicalProduct @relation(fields: [productId], references: [id])
  details Article?        @relation(fields: [detailsId], references: [id])

  transactions TransactionBuyItemPhysicalItem[]
}

model DigitalProduct {
  // user can buy same digital product multiple times to extend validity
  id            Int    @id @default(autoincrement())
  productId     Int    @unique
  descriptionId Int    @unique
  metadataJson  String
  seriesId      Int?

  product     Product               @relation(fields: [productId], references: [id])
  series      DigitalProductSeries? @relation(fields: [seriesId], references: [id])
  description Article               @relation(fields: [descriptionId], references: [id])

  items DigitalProductItem[]
  files PrivateFile[]
}

model DigitalProductSeries {
  id      Int    @id @default(autoincrement())
  name    String @unique
  ownerId Int

  owner Actor            @relation(fields: [ownerId], references: [id])
  items DigitalProduct[]
}

model DigitalProductItem {
  id               Int  @id @default(autoincrement())
  productId        Int
  price            Int
  stockQuantity    Int?
  validityDuration Int? // how long user can view the content, null if infinity

  product      DigitalProduct              @relation(fields: [productId], references: [id])
  transactions TransactionBuyItemDigital[]

  @@unique([productId, validityDuration])
}

model UserDigitalProduct {
  id        Int       @id @default(autoincrement())
  userId    Int
  productId Int
  createdAt DateTime  @default(now())
  expiresAt DateTime?

  items UserDigitalProductItem[]
}

model UserDigitalProductItem {
  userDigitalProductId Int
  createdAt            DateTime  @default(now())
  transactionId        Int       @unique
  startAt              DateTime?

  userDigitalProduct UserDigitalProduct        @relation(fields: [userDigitalProductId], references: [id])
  transaction        TransactionBuyItemDigital @relation(fields: [transactionId], references: [id])

  @@id([userDigitalProductId, createdAt])
}

enum TransactionType {
  CHARGE_CREDIT
  BUY
  REFUND
  SETTLE_SALES
  CASH_OUT_CREDIT
}

model Transaction {
  id                   Int             @id @default(autoincrement())
  type                 TransactionType
  userId               Int
  createdAt            DateTime        @default(now())
  userCreditBefore     Int
  userCreditAfterCache Int

  buyId           Int? @unique
  chargeCreditId  Int? @unique
  refundId        Int? @unique
  settleSalesId   Int? @unique
  cashOutCreditId Int? @unique

  user User @relation(fields: [userId], references: [id])

  buy           TransactionBuy?           @relation(fields: [buyId], references: [id])
  chargeCredit  TransactionChargeCredit?  @relation(fields: [chargeCreditId], references: [id])
  refund        TransactionRefund?        @relation(fields: [refundId], references: [id])
  settleSales   TransactionSettleSales?   @relation(fields: [settleSalesId], references: [id])
  cashOutCredit TransactionCashOutCredit? @relation(fields: [cashOutCreditId], references: [id])

  @@index([userId, createdAt])
  @@index([userId, type, createdAt])
}

model TransactionChargeCredit {
  id          Int @id @default(autoincrement())
  creditCount Int

  transaction Transaction?
}

model TransactionBuy {
  id                    Int                  @id @default(autoincrement())
  items                 TransactionBuyItem[]
  priceSumCacheSnapshot Int
  refundedCredit        Int

  transaction Transaction?
}

enum TransactionBuyItemType {
  PYHSICAL
  DIGITAL
}

model TransactionBuyItem {
  id                    Int                    @id @default(autoincrement())
  transactionId         Int
  priceSumCacheSnapshot Int
  reviewId              Int?                   @unique
  type                  TransactionBuyItemType

  physicalId Int? @unique
  digitalId  Int? @unique

  physical TransactionBuyItemPhysical? @relation(fields: [physicalId], references: [id])
  digital  TransactionBuyItemDigital?  @relation(fields: [physicalId], references: [id])

  review             Review?                     @relation(fields: [reviewId], references: [id])
  transaction        TransactionBuy              @relation(fields: [transactionId], references: [id])
  refundTransactions TransactionRefund[]
  settleSalesItem    TransactionSettleSalesItem?
}

model TransactionBuyItemPhysical {
  id Int @id @default(autoincrement())

  parent TransactionBuyItem?
  items  TransactionBuyItemPhysicalItem[]
}

enum TransactionBuyItemPhysicalItemType {
  ORIGINAL
  ADDON
  SELECT_ITEM
  OPTION
}

model TransactionBuyItemPhysicalItem {
  id                     Int                                @id @default(autoincrement())
  parentId               Int
  type                   TransactionBuyItemPhysicalItemType
  pricePerCountSnapshot  Int
  count                  Int
  refundedCount          Int
  valueJson              String? // required on option
  confirmedAt            DateTime?
  confirmedAutomatically Boolean                            @default(false)

  originalId   Int?
  addonId      Int?
  selectItemId Int?
  optionId     Int?

  original   PhysicalProduct?           @relation(fields: [originalId], references: [id])
  addon      PhysicalProductAddon?      @relation(fields: [addonId], references: [id])
  selectItem PhysicalProductSelectItem? @relation(fields: [selectItemId], references: [id])
  option     PhysicalProductOption?     @relation(fields: [optionId], references: [id])

  parent TransactionBuyItemPhysical @relation(fields: [parentId], references: [id])
}

model TransactionBuyItemDigital {
  id                       Int  @id @default(autoincrement())
  itemId                   Int
  priceSnapshot            Int // from DigitalProductItem::price
  validityDurationSnapshot Int? // from DigitalProductItem::validityDuration

  parent TransactionBuyItem?
  item   DigitalProductItem  @relation(fields: [itemId], references: [id])

  userDigitalProductItem UserDigitalProductItem?
}

model TransactionRefund {
  id             Int      @id @default(autoincrement())
  refundedCredit Int
  refundedAt     DateTime
  remainCredit   Int
  itemId         Int

  transaction Transaction?
  item        TransactionBuyItem @relation(fields: [itemId], references: [id])
}

model TransactionSettleSales {
  id          Int                          @id @default(autoincrement())
  items       TransactionSettleSalesItem[]
  creditCount Int

  transaction Transaction?
}

model TransactionSettleSalesItem {
  id            Int @id @default(autoincrement())
  transactionId Int
  itemId        Int @unique

  transaction TransactionSettleSales @relation(fields: [transactionId], references: [id])
  item        TransactionBuyItem     @relation(fields: [itemId], references: [id])
}

model TransactionCashOutCredit {
  id          Int @id @default(autoincrement())
  creditCount Int

  transaction Transaction?
}
